---
layout: post
title: "Writing SOLID Code (SOLID Design Principles Reflected in the Enterprise API Framework)"
date: 2015-09-10 12:00:00
author: Qiang Xue
tags: [framework, RESTful API, design patterns, SOLID]
category: blog
---

At Capital One, we have developed an Enterprise API (eAPI) Framework to simplify the development of API applications that conform to the enterprise standards. The framework offers a set of enterprise features, such as message management, audit logging, enterprise security, etc. It also provides starter packages that are skeleton code for jumpstarting new API application development. In this post, I will explain how the so-called SOLID principles are being followed by the skeleton code generated by eAPI to foster software quality, maintainability, and reuse while enabling cross-team delivery consistency.

<!--more-->

[SOLID](https://en.wikipedia.org/wiki/SOLID_(object-oriented_design)) is a mnemonic acronym for the five object-oriented design (OOD) principles by [Robert C. Martin](https://en.wikipedia.org/wiki/Robert_Cecil_Martin) for writing cleaner and more maintainable code. SOLID means:

* Single Responsibility Principle
* Open/Closed Principle
* Liskov Substitution Principle
* Interface Segregation Principle
* Dependency Inversion Principle


## The Single-Responsibility Principle (SRP)

SRP says that a class should have only a single responsibility. It is the UNIX principle "do one thing and do it well". When a class assumes multiple responsibilities, changes to one responsibility may impact the class's ability to meet the others, and consequently may cause the class to break in unexpected ways.

Let's take a look at how the skeleton RESTful API application generated by the eAPI framework meets SRP. The following class diagram shows the main classes/interfaces and their relationships in the skeleton application.

![Class Diagram of the Skeleton Code]({{ site.baseurl }}/assets/posts/writing-solid-code/solid.png)

As you can see, in order to implement the RESTful APIs that expose the BankThing data, three classes/interfaces are created, each assuming different responsibilities. The BankThingResource class is responsible for parsing the incoming HTTP requests, invoking the requested services, and sending back the responses. The BankThingService interface is responsible for providing services that support interacting with the BankThing data in different ways. And the BankThingsDao interface is responsible for keeping the BankThing data in persistent storage.

What if we combine both BankThingResource and BankThingService into a single class? This would create a class that is sensitive to requirement changes along two axes (e.g. adding a new RESTful API endpoint; modifying a data query method). Each change may force us to rebuild, retest, and redeploy the dependent applications, even if an application is irrelevant to the change.

SRP is a very broad principle. In fact, the rest of the SOLID principles can be more or less considered as a derivative of SRP.


## The Open/Closed Principle (OCP)

OCP says that software entities (classes, modules, functions, etc.) should allow customization or enhancement (open) without modifying the original code (closed). While OCP may not be easily understood by reading the words, it is actually very common to see in practice.

Let's use the eAPI skeleton code to explain this principle. The BankThingServiceImpl class uses the BankThingsDao interface which is implemented by HashMapBankThingsDao. What is the value of having the interface BankThingsDao, and why not letting BankThingServiceImpl to directly use HashMapBankThingsDao? This is all because of OCP. The abstraction of the interface allows BankThingServiceImpl to use different storage for the BankThing objects without modifying the code of BankThingServiceImpl. Should we directly reference HashMapBankThingsDao in BankThingServiceImpl, we would have to modify BankThingServiceImpl whenever we want to use a different DAO class.

Instead of using interfaces, you may also use base abstract classes to achieve OCP. The key is to use abstraction in references to avoid coupling with concrete implementations.


## The Liskov Substitution Principle (LSP)

LSP says that subtypes must be substitutable for their base types. For example, if a function takes a parameter of type T, then the function should still work properly when it is provided with a parameter of S which is a subtype of T. A common cause of LSP violations is the improper inheritance between classes, which is illustrated by the famous [circle-ellipse problem](https://en.wikipedia.org/wiki/Circle-ellipse_problem). Another cause of LSP violations is related with having type-checking code which may fail to work when a subtype is not covered.


## The Interface Segregation Principle (ISP)

ISP states that many client-specific interfaces are better than one general-purpose interface. This principle can be understood as a special application of SRP to interfaces. If an interface has methods that can be broken into groups, each serving a different set of clients, we say the interface is "fat" and violates ISP. According to SRP, it means the same interface is assuming multiple responsibilities. To solve this problem, the "fat" interface should be replaced with multiple client-specific interfaces.

Reviewing the two interfaces in the eAPI skeleton code, we can conclude that they are well segregated. The BankThingService interface specifies the methods for clients like BankThingResource who is mainly interested in various ways of interacting with the BankThing data, while the BankThingsDao interface contains the methods for clients who want to persist data in storage space.


## The Dependency-Inversion Principle (DIP)

DIP consists of two statements. The first statement says that high-level modules should not depend on low-level modules - both should depend on abstractions. The second statement says that abstractions should not depend upon details - details should depend upon abstractions.

A well-structured object-oriented system usually consists of modules belonging to clearly-defined layers. High-level modules are like policy makers who decide how the system should look like, while low-level layers are implementing the specified policies. Therefore, it does not make sense to let high-level modules to depend on low-level modules. As OCP says, it is also problematic to have low-level modules to directly depend on concrete high-level modules. Abstractions should be created to decouple low-level and high-level modules. And because of the first statement, such abstractions should belong to high-level modules.

Now let's examine if the eAPI skeleton code follows DIP. There are two layers in the eAPI code. The web layer is the upper layer which consists of BankThingResource, and the service layer is the lower layer which has the rest of the classes and interfaces we mentioned. If we would draw a dependency line between the two layers, we would see that the upper layer depends upon the lower layer. For example, if we make changes to the BankThingService interface in the lower layer, we could break the upper layer if it does not change accordingly. On the other hand, the code does introduce interfaces and let details to depend upon abstractions instead of the other way around. Therefore, we may conclude that the eAPI skeleton code partially violates DIP.

Is this an issue? I wouldn't think so. If the service is being used by many clients, it makes sense to keep the interface within the service layer. Or even better, put the interface in a separate package and let both the service and the web layers to depend on this package.


## Summary

SOLID are general guidelines for writing good object-oriented code. Sometimes it may collide with other similar principles, such as DRY (don't repeat yourself), KISS (keep it simple stupid). It may also collide with the reality of requirements, the limitations of programming languages, etc. In these situations, breaking SOLID may be fine for trading off benefits obtained on other aspects.

SOLID may seem quite daunting if you have just learned about it. If you couldn't remember or understand all these principles, that's totally fine. Just keep it in mind that you should avoid tight coupling in your code, as this is what SOLID is all about. Keep practicing this while coding, and you will immediately start writing better code.
